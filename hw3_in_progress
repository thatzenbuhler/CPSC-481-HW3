#include "ros/ros.h"
#include "geometry_msgs/Twist.h"
#include "turtlesim/Pose.h"
#include <sstream>
#include <turtlesim/Spawn.h>
#include <turtlesim/Kill.h>
#include <stdlib.h>
#include <ros/master.h>
#include <boost/algorithm/string.hpp>
#include <vector>
#define NUM_T 7 // Number of T turtles
#define NUM_X 17 // Number of X turtles

using namespace std;
int g_iterator = 0; // For tracking vector of pose positions
bool calledback = false; // For tracking successful callback per turtle
string tempturtle = "/T1/pose"; // First name for searching for T turtles
string Xtempturtle = "/X1/pose"; // First name for searching for T turtles

//publisher and subscriber
ros::Publisher velocity_publisher;
ros::Subscriber pose_subscriber;
//test
ros::Subscriber T_pose_subscriber;
turtlesim::Pose turtlesim_pose;

struct TurtlePose {
  std::string turtlename;
  std::string topicname;
  turtlesim::Pose pose;
};

struct TurtleStruct {
	turtlesim::Pose pose;
	bool isX;
	bool isT;
};

static ros::ServiceClient sClient;
static ros::ServiceClient kClient;

double getDistance(const double x1, const double y1, const double x2, const double y2);
//not working
void moveGoal(turtlesim::Pose goal_pose, double distance_tolerance);
bool isTooClose(double x1, double y1, double x2, double y2, double threshhold);
void removeTurtle(std::string turtlename);
void poseCallback(const turtlesim::Pose::ConstPtr & pose_message);
void addToVector();
void poseCB(const turtlesim::Pose::ConstPtr & pose_message);
//new version of move goal
void goal(turtlesim::Pose gp, double dt);
//test rotate
void rotate (TurtleStruct gp);
//test move
void move(double dist);

vector<TurtleStruct> spawnedTurtles;
int vIndex = 0;
float x, y, t;

int main (int argc, char **argv)
{
	ros::init(argc, argv, "turtle");
	ros::NodeHandle n;
	ros::Rate loop_rate(10);
	
	//initialize publisher
	velocity_publisher = n.advertise<geometry_msgs::Twist>("/turtle1/cmd_vel", 10);
	pose_subscriber = n.subscribe("/turtle1/pose", 10, poseCallback);
	ROS_INFO("Scanning for friendly turtles...\n");
	
	while(ros::ok() && g_iterator < NUM_T){
		//try to subscribe to Tturtles
		T_pose_subscriber = n.subscribe(tempturtle.c_str(), 10, poseCB);
		ros::spinOnce();
	}
	ROS_INFO("All friendly turtles found! Now moving to enemy turtles.");
	T_pose_subscriber.shutdown();
	//g_iterator = 0;
	
	ROS_INFO("Scanning for enemy turtles...\n");
	
	while(ros::ok() && g_iterator < NUM_X){
		//try to subscribe to X turtles
		T_pose_subscriber = n.subscribe(Xtempturtle.c_str(), 10, poseCB);
		ros::spinOnce();
	}
	ROS_INFO("All enemy turtles found! Now moving to capture.");
	T_pose_subscriber.shutdown();
	
	// Start capturing turtles, closest one at a time
	/*
	bool found[NUM_T] = {false};
	bool allfound = false;
	while(allfound = false){
		double current_distance[NUM_T];
		for(int i = 0; i < NUM_T; i++){
			current_distance[i] = getDistance(turtlesim_pose.x, turtlesim_pose.y, spawnedTurtles[i].pose.x, spawnedTurtles[i].pose.y);
		}
		int closest = 0;
		for(int i = 0; i < NUM_T - 1; i++){
			if(current_distance[i+1] < current_distance[i] && found[i] == false){
				closest = i + 1;
			}
		}
		moveGoal(spawnedTurtles[closest].pose, 0.5);
		found[closest] = true;
		
		//test my rot func
		rotate (spawnedTurtles[closest]);
		ROS_INFO("Rotated turtle");
		
		// Check if all turtles found
		allfound = true;
		for(int i = 0; i < NUM_T; i++){
			if(found[i] == false) allfound = false;
		}
	}
	*/
	
	double near = 100;
	int index = 0;
	int count = 0;
	
	while (count < NUM_T)
	{
		double dist;
		dist = getDistance(turtlesim_pose.x, turtlesim_pose.y, spawnedTurtles[count].pose.x, spawnedTurtles[count].pose.y);
		if (dist <= near)
		{
			near = dist;
			index = count;
		}
		
		++count;
	}
	
	ROS_INFO("The closest turtle is T%i at X:%f   Y:%f", index, spawnedTurtles[index].pose.x, spawnedTurtles[index].pose.y);
	
	rotate (spawnedTurtles[index]);
	move (near);

	
	ros::spin();
}

void rotate (TurtleStruct gp)
{
	geometry_msgs::Twist vel_msg;
	double curr_ang = 0.0;	
	double t0 = ros::Time::now().toSec();
	ros::Rate loop_rate(10);
	double ang_speed = 2;

	double angl = 0.0174533 * (atan2(gp.pose.y - turtlesim_pose.y, gp.pose.x - turtlesim_pose.x) - turtlesim_pose.theta);
		
	//no linear velocity
	vel_msg.linear.x = 0;
	vel_msg.linear.y = 0;
	vel_msg.linear.z = 0;
	vel_msg.angular.x = 0;
	vel_msg.angular.y = 0;
	vel_msg.angular.z = ang_speed;
	
	do {
		velocity_publisher.publish(vel_msg);
		double t1 = ros::Time::now().toSec();
		curr_ang = ang_speed * (t1 - t0);
		ros::spinOnce();
		loop_rate.sleep();
	
	}while (curr_ang < angl);
	
	//force turtle to stop moving once loop is complete
	vel_msg.angular.z = 0;
	velocity_publisher.publish(vel_msg);

}

void move(double dist)
{
	geometry_msgs::Twist vel_msg;
	double t0 = ros::Time::now().toSec();
	double curr_dist = 0;
	ros::Rate loop_rate(100);
	double speed = 2;
	
	vel_msg.linear.x = speed;
	vel_msg.linear.y = 0;
	vel_msg.linear.z = 0;
	vel_msg.angular.x = 0;
	vel_msg.angular.y = 0;
	vel_msg.angular.z = 0;
	
	do {
		velocity_publisher.publish(vel_msg);
		double t1 = ros::Time::now().toSec();
		curr_dist = speed * (t1 - t0);
		ros::spinOnce();
		loop_rate.sleep();
	
	}while (curr_dist < dist);
	
	//force turtle to stop moving once loop is complete
	vel_msg.linear.x = 0;
	velocity_publisher.publish(vel_msg);
}

// Euclidian distance
double getDistance(const double x1, const double y1, const double x2, const double y2) {
  return sqrt(pow((x1-x2),2) + pow(y1-y2, 2));
}

void moveGoal(turtlesim::Pose goal_pose, double distance_tolerance){
	geometry_msgs::Twist vel_msg;
	ros::Rate loop_rate(100);
	double E = 0.0;
	do{
		double Kv = 0.2;
		double e = getDistance(turtlesim_pose.x, turtlesim_pose.y, goal_pose.x, goal_pose.y);
		vel_msg.linear.x = (Kv * e);
		vel_msg.linear.y = 0;
		vel_msg.linear.z = 0;
		vel_msg.angular.x = 0;
		vel_msg.angular.y = 0;
		double Kw = 1;
		vel_msg.angular.z = Kw*(atan2(goal_pose.y - turtlesim_pose.y, goal_pose.x - turtlesim_pose.x) - turtlesim_pose.theta);
		velocity_publisher.publish(vel_msg);
		ros::spinOnce();
		loop_rate.sleep();
	} while(getDistance(turtlesim_pose.x, turtlesim_pose.y, goal_pose.x, goal_pose.y) > distance_tolerance);
	vel_msg.linear.x = 0;
	vel_msg.angular.z = 0;
	velocity_publisher.publish(vel_msg);
}

// Check if contact is close
bool isTooClose(double x1, double y1, double x2, double y2, double threshhold) {
  if (getDistance(x1, y1, x2, y2) <= threshhold)
     return true;
  else
     return false;
}

// Remove captured turtle
void removeTurtle(std::string turtlename) {
  turtlesim::Kill::Request reqk;
  turtlesim::Kill::Response respk;

  reqk.name = turtlename.c_str();
  if (!kClient.call(reqk, respk))
     ROS_ERROR_STREAM("Error: Failed to kill " << reqk.name.c_str() << "\n");
}

void poseCallback(const turtlesim::Pose::ConstPtr & pose_message)
{
	turtlesim_pose.x = pose_message -> x;
	turtlesim_pose.y = pose_message -> y;
	turtlesim_pose.theta = pose_message -> theta;
}

void poseCB(const turtlesim::Pose::ConstPtr & pose_message)
{
	addToVector();
	spawnedTurtles[g_iterator].pose.x = pose_message -> x;
	spawnedTurtles[g_iterator].pose.y = pose_message -> y;
	spawnedTurtles[g_iterator].pose.theta = pose_message -> theta;
	calledback = true;
	if (g_iterator < 7)
	{
		ROS_INFO("X position of T%d turtle is %f .", g_iterator + 1, spawnedTurtles[g_iterator].pose.x);
		ROS_INFO("Y position of T%d turtle is %f .\n", g_iterator + 1, spawnedTurtles[g_iterator].pose.y);
		g_iterator++;
		tempturtle[2] = 48 + g_iterator + 1;
	}
	else if ((g_iterator >= 7) && (g_iterator < 17))
	{
		ROS_INFO("X position of X%d turtle is %f .", g_iterator - 6, spawnedTurtles[g_iterator].pose.x);
		ROS_INFO("Y position of X%d turtle is %f .\n", g_iterator - 6, spawnedTurtles[g_iterator].pose.y);
		g_iterator++;
		if (Xtempturtle[2] != 57)
		{
			Xtempturtle[2] = 48 + g_iterator - 6;
		}
		else
		{
			Xtempturtle = "/X10/pose";
		}
		
	}
	
}

void addToVector()
{
	TurtleStruct temp;
	temp.pose.x = 0;
	temp.pose.y = 0;
	temp.pose.theta = 0;
	
	spawnedTurtles.push_back(temp);
	
	
}







